<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WEBCAM SHOWCASE v2 — 20 DISTINCT PRESETS (DESKTOP FIXED)</title>
  <style>
    :root{
      --bg:#07080a; --fg:#e7e8ea; --muted:#a7aab0;
      --panel:rgba(0,0,0,.55); --panel2:rgba(0,0,0,.35);
      --line:rgba(255,255,255,.12); --shadow:0 12px 40px rgba(0,0,0,.5);
      --ok:#6dff8a; --bad:#ff3b3b;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{position:fixed;inset:0;overflow:hidden;background:radial-gradient(1200px 800px at 50% 45%, rgba(255,255,255,.04), transparent 55%)}
    #c{position:absolute;inset:0;width:100%;height:100%}
    #hud{position:absolute;left:14px;right:14px;top:14px;display:grid;grid-template-columns:1fr auto;gap:10px;pointer-events:none}
    .card{pointer-events:auto;background:var(--panel);border:1px solid var(--line);box-shadow:var(--shadow);border-radius:12px;padding:12px;backdrop-filter:blur(10px)}
    #titleRow{display:flex;align-items:baseline;gap:10px;flex-wrap:wrap}
    #presetName{font-weight:800;letter-spacing:.2px}
    #presetIdx{color:var(--muted);font-weight:650}
    #desc{margin-top:6px;color:var(--muted);line-height:1.35;font-size:13px;max-width:86ch}
    #status{margin-top:10px;font-size:12px;color:var(--muted);display:grid;gap:6px}
    .pillRow{display:flex;flex-wrap:wrap;gap:6px}
    .pill{border:1px solid var(--line);background:var(--panel2);padding:4px 8px;border-radius:999px;font-size:12px;color:var(--muted);user-select:none}
    .pill.ok{color:var(--ok);border-color:rgba(109,255,138,.25)}
    .pill.bad{color:var(--bad);border-color:rgba(255,59,59,.25)}
    #controls{pointer-events:auto;display:flex;gap:8px;align-items:center;justify-content:flex-end}
    button{background:rgba(255,255,255,.06);border:1px solid var(--line);color:var(--fg);border-radius:10px;padding:10px 12px;font-weight:700;letter-spacing:.2px;cursor:pointer;user-select:none}
    button:hover{background:rgba(255,255,255,.09)}
    button:active{transform:translateY(1px)}
    button.primary{background:rgba(109,255,138,.10);border-color:rgba(109,255,138,.22)}
    button.danger{background:rgba(255,59,59,.10);border-color:rgba(255,59,59,.22)}
    #footer{position:absolute;left:14px;right:14px;bottom:14px;display:grid;grid-template-columns:1fr auto;gap:10px;pointer-events:none}
    #tip{pointer-events:auto;background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:10px 12px;color:var(--muted);font-size:12px;box-shadow:var(--shadow);backdrop-filter:blur(10px)}
    #tip b{color:var(--fg)}
    #mini{pointer-events:auto;background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:10px 12px;color:var(--muted);font-size:12px;box-shadow:var(--shadow);backdrop-filter:blur(10px);display:flex;align-items:center;gap:10px}
    #mini input[type="range"]{width:180px}
    #startOverlay{position:absolute;inset:0;display:grid;place-items:center;background:radial-gradient(900px 600px at 50% 40%, rgba(255,255,255,.06), rgba(0,0,0,.72) 55%, rgba(0,0,0,.88))}
    #startCard{width:min(760px,calc(100% - 28px));border-radius:18px;padding:18px;border:1px solid var(--line);background:rgba(0,0,0,.60);box-shadow:var(--shadow);backdrop-filter:blur(12px)}
    #startCard h1{margin:0 0 8px 0;font-size:18px;letter-spacing:.2px}
    #startCard p{margin:0 0 12px 0;color:var(--muted);line-height:1.4;font-size:13px}
    #startCard .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    #startCard .warn{color:#ffb4b4}
    #dbg{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;white-space:pre-wrap;font-size:11px;color:rgba(231,232,234,.72);margin-top:10px;border-top:1px solid var(--line);padding-top:10px;max-height:240px;overflow:auto}
    #dbg .bad{color:#ffb4b4}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div id="hud">
    <div class="card">
      <div id="titleRow">
        <div id="presetName">—</div>
        <div id="presetIdx">—</div>
      </div>
      <div id="desc">—</div>
      <div id="status">
        <div class="pillRow" id="capPills"></div>
        <div class="pillRow" id="applyPills"></div>
      </div>
    </div>

    <div class="card" id="controls">
      <button id="prevBtn" title="Previous (←)">◀</button>
      <button id="nextBtn" title="Next (→)">▶</button>
      <button id="fsBtn" class="primary" title="Fullscreen">Fullscreen</button>
      <button id="reapplyBtn" title="Re-apply constraints">Re-apply</button>
      <button id="stopBtn" class="danger" title="Stop camera">Stop</button>
    </div>
  </div>

  <div id="footer">
    <div id="tip">
      <b>Keys:</b> ←/→ presets · <b>F</b> fullscreen · <b>R</b> re-apply · <b>Space</b> pause · <b>Esc</b> exit fullscreen.
      <br><b>Desktop rule:</b> open via <b>http://localhost</b>, not <b>file://</b>, or camera can fail/grey out.
    </div>
    <div id="mini">
      <span>Intensity</span>
      <input id="intensity" type="range" min="0" max="100" value="70" />
      <span id="intVal">70%</span>
    </div>
  </div>

  <div id="startOverlay">
    <div id="startCard">
      <h1>WEBCAM SHOWCASE v2 — 20 distinct presets (DESKTOP FIXED)</h1>
      <p>
        If desktop shows a grey field, it’s almost always: <span class="warn">file://</span>, permissions, or no frames yet.
        This build waits for frames and displays exact camera readiness in the overlay.
      </p>
      <div class="row">
        <button id="startBtn" class="primary">START</button>
        <button id="startFsBtn">START + Fullscreen</button>
      </div>
      <div id="dbg"></div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // ---------- DOM ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false, desynchronized:true });

  const presetNameEl = document.getElementById("presetName");
  const presetIdxEl  = document.getElementById("presetIdx");
  const descEl       = document.getElementById("desc");
  const capPillsEl   = document.getElementById("capPills");
  const applyPillsEl = document.getElementById("applyPills");

  const startOverlay = document.getElementById("startOverlay");
  const startBtn     = document.getElementById("startBtn");
  const startFsBtn   = document.getElementById("startFsBtn");
  const dbgEl        = document.getElementById("dbg");

  const prevBtn      = document.getElementById("prevBtn");
  const nextBtn      = document.getElementById("nextBtn");
  const fsBtn        = document.getElementById("fsBtn");
  const reapplyBtn   = document.getElementById("reapplyBtn");
  const stopBtn      = document.getElementById("stopBtn");

  const intensityEl  = document.getElementById("intensity");
  const intValEl     = document.getElementById("intVal");

  // ---------- State ----------
  let W=0,H=0,DPR=1;
  let running=false, paused=false;
  let presetIndex=0;
  let tStart = performance.now();
  let intensity = 0.70;

  let stream=null, track=null, caps=null;

  const video = document.createElement("video");
  video.playsInline = true;
  video.muted = true;
  video.autoplay = true;

  // Low-res processing buffers
  const src = document.createElement("canvas");  // primary input
  const sctx = src.getContext("2d", { alpha:false, willReadFrequently:true });

  const fxA = document.createElement("canvas");
  const actx = fxA.getContext("2d", { alpha:false, willReadFrequently:true });

  const fxB = document.createElement("canvas");
  const bctx = fxB.getContext("2d", { alpha:false, willReadFrequently:true });

  const tmp = document.createElement("canvas");
  const tctx = tmp.getContext("2d", { alpha:false, willReadFrequently:true });

  const tiny = document.createElement("canvas"); // for pixelate/halftone/ascii
  const tinctx = tiny.getContext("2d", { alpha:false, willReadFrequently:true });

  // Delay ring buffer for temporal effects
  const delayN = 64;
  const delayFrames = new Array(delayN).fill(null).map(()=>document.createElement("canvas"));
  const delayCtxs   = delayFrames.map(c=>c.getContext("2d",{alpha:false,willReadFrequently:true}));
  let delayHead = 0;

  // Motion detection
  let prevImg = null;  // ImageData
  const motion = document.createElement("canvas");
  const mctx = motion.getContext("2d", { alpha:false, willReadFrequently:true });
  let motionInit=false;

  // Face detection
  let faceDetector=null;
  let faceRect=null; // in src coords
  let lastFaceT=0;

  // Per-preset ephemeral state
  const PSTATE = Object.create(null);

  // ---------- Utils ----------
  function log(msg){
    dbgEl.textContent = (dbgEl.textContent + msg + "\n").slice(-9000);
    dbgEl.scrollTop = dbgEl.scrollHeight;
  }
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const fract=(x)=>x-Math.floor(x);
  const smoothstep=(a,b,t)=>{ t=clamp((t-a)/(b-a),0,1); return t*t*(3-2*t); };
  const nowS=()=>performance.now()*0.001;
  const TAU = Math.PI*2;

  function hash1(n){
    const x = Math.sin(n*127.1 + 311.7)*43758.5453123;
    return fract(x);
  }
  function rng(seed){
    let s = seed|0;
    return ()=> {
      s = (s*1664525 + 1013904223) | 0;
      return ((s>>>0) / 4294967296);
    };
  }

  function isFileProtocol(){
    return location.protocol === "file:";
  }

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width=W; canvas.height=H;
    canvas.style.width="100%"; canvas.style.height="100%";

    // source processing at half-res for speed
    const sw = Math.max(320, Math.floor(W*0.5));
    const sh = Math.max(240, Math.floor(H*0.5));
    src.width=sw; src.height=sh;
    fxA.width=sw; fxA.height=sh;
    fxB.width=sw; fxB.height=sh;
    tmp.width=sw; tmp.height=sh;

    // motion map even lower
    motion.width = Math.max(120, Math.floor(sw*0.35));
    motion.height= Math.max(90,  Math.floor(sh*0.35));
    motionInit=false; prevImg=null;

    // delay frames
    for(let i=0;i<delayN;i++){ delayFrames[i].width=sw; delayFrames[i].height=sh; }

    // clear screens on resize
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle="#0b0c10";
    ctx.fillRect(0,0,W,H);
  }
  window.addEventListener("resize", resize);

  function pill(text, cls=""){
    const d=document.createElement("div");
    d.className="pill "+cls;
    d.textContent=text;
    return d;
  }

  function setCapPills(){
    capPillsEl.innerHTML="";
    if(!caps){
      capPillsEl.appendChild(pill("no capabilities yet", "bad"));
      return;
    }
    const keys = [
      "zoom","focusDistance","focusMode","exposureCompensation","exposureMode",
      "whiteBalanceMode","colorTemperature","torch","pointsOfInterest",
      "brightness","contrast","saturation","sharpness"
    ];
    const supported = keys.filter(k => caps[k] !== undefined);
    if(!supported.length){
      capPillsEl.appendChild(pill("device exposes: mostly basics only", "bad"));
    } else {
      capPillsEl.appendChild(pill("device exposes:", "ok"));
      supported.forEach(k=>capPillsEl.appendChild(pill(k,"ok")));
    }
  }

  function settingsSummary(){
    if(!track || !track.getSettings) return "no getSettings()";
    const s = track.getSettings();
    const keys = ["width","height","frameRate","zoom","focusDistance","exposureCompensation","colorTemperature","torch"];
    const bits=[];
    for(const k of keys){
      if(s[k] !== undefined){
        bits.push(`${k}:${typeof s[k]==="number" ? s[k].toFixed(2) : s[k]}`);
      }
    }
    return bits.join(" · ") || "settings: (empty)";
  }

  async function applyConstraintsForPreset(p){
    applyPillsEl.innerHTML="";
    if(!track || !track.applyConstraints){
      applyPillsEl.appendChild(pill("applyConstraints: not available", "bad"));
      return;
    }

    const base = p.baseConstraints || {};
    const adv  = p.advancedConstraints || null;

    const requested = [];
    for(const k of Object.keys(base)) requested.push(k);
    if(adv) for(const k of Object.keys(adv)) requested.push("adv."+k);

    if(!requested.length){
      applyPillsEl.appendChild(pill("no constraints requested (processing-only)", "ok"));
      applyPillsEl.appendChild(pill(settingsSummary(), "ok"));
      return;
    }

    applyPillsEl.appendChild(pill("requested:", "ok"));
    requested.slice(0,10).forEach(k=>applyPillsEl.appendChild(pill(k, "ok")));
    if(requested.length>10) applyPillsEl.appendChild(pill(`(+${requested.length-10} more)`, "ok"));

    try{
      const c = Object.assign({}, base);
      if(adv) c.advanced = [adv];
      await track.applyConstraints(c);
      applyPillsEl.appendChild(pill("apply: success (device may still ignore)", "ok"));
    } catch(e){
      applyPillsEl.appendChild(pill(`apply: rejected (${e.name||"error"})`, "bad"));
      log("applyConstraints rejected: " + (e.name||"") + " " + (e.message||""));
    }

    applyPillsEl.appendChild(pill(settingsSummary(), "ok"));
  }

  async function enterFullscreen(){
    try{
      if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
    }catch{}
  }

  // ====== DESKTOP FIX: wait for frames + safe draw ======
  function drawVideoCoverSafe(dstCtx){
    const sw = dstCtx.canvas.width, sh = dstCtx.canvas.height;

    // Wait until the video is actually producing frames
    if (video.readyState < 2 || !video.videoWidth || !video.videoHeight) {
      dstCtx.fillStyle = "#141518";
      dstCtx.fillRect(0,0,sw,sh);
      dstCtx.fillStyle = "rgba(255,255,255,0.70)";
      dstCtx.font = "12px ui-monospace, monospace";
      dstCtx.fillText("waiting for camera frames…", 10, 18);
      dstCtx.fillStyle = "rgba(255,255,255,0.45)";
      dstCtx.fillText(`readyState:${video.readyState} w:${video.videoWidth||0} h:${video.videoHeight||0}`, 10, 34);
      return false;
    }

    try {
      const vw = video.videoWidth, vh = video.videoHeight;
      const vr = vw/vh, sr = sw/sh;

      let sx=0, sy=0, sww=vw, shh=vh;
      if(vr > sr){
        sww = vh*sr;
        sx = (vw - sww)*0.5;
      } else {
        shh = vw/sr;
        sy  = (vh - shh)*0.5;
      }
      dstCtx.imageSmoothingEnabled=true;
      dstCtx.drawImage(video, sx, sy, sww, shh, 0,0, sw, sh);
      return true;
    } catch(e) {
      dstCtx.fillStyle = "#141518";
      dstCtx.fillRect(0,0,sw,sh);
      dstCtx.fillStyle = "rgba(255,120,120,0.85)";
      dstCtx.font = "12px ui-monospace, monospace";
      dstCtx.fillText("camera draw failed (see console)", 10, 18);
      console.warn("drawImage(video) failed:", e);
      return false;
    }
  }

  function blitToScreen(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    const sw=fxA.width, sh=fxA.height;
    const sr=sw/sh, dr=W/H;
    let dw=W, dh=H, dx=0, dy=0;
    if(sr > dr){ dh=H; dw=H*sr; dx=(W-dw)*0.5; }
    else       { dw=W; dh=W/sr; dy=(H-dh)*0.5; }

    ctx.imageSmoothingEnabled=true;
    ctx.drawImage(fxA, dx,dy,dw,dh);
  }

  // ---------- Motion map ----------
  function computeMotionMap(){
    const mw = motion.width, mh = motion.height;
    mctx.drawImage(src, 0,0,mw,mh);
    const img = mctx.getImageData(0,0,mw,mh);
    if(!motionInit || !prevImg){
      prevImg = img;
      motionInit = true;
      return { mw, mh, motionData: new Uint8ClampedArray(mw*mh), avg:0 };
    }
    const prev = prevImg.data;
    const cur  = img.data;
    const out  = new Uint8ClampedArray(mw*mh);
    let sum=0;

    for(let i=0, p=0; i<cur.length; i+=4, p++){
      const dr = Math.abs(cur[i]-prev[i]);
      const dg = Math.abs(cur[i+1]-prev[i+1]);
      const db = Math.abs(cur[i+2]-prev[i+2]);
      const d = (dr+dg+db)/3;
      const v = clamp(d*2.0, 0, 255);
      out[p]=v;
      sum += v;

      prev[i]   = (prev[i]*0.90 + cur[i]*0.10)|0;
      prev[i+1] = (prev[i+1]*0.90 + cur[i+1]*0.10)|0;
      prev[i+2] = (prev[i+2]*0.90 + cur[i+2]*0.10)|0;
      prev[i+3] = 255;
    }
    prevImg = { data: prev };
    const avg = sum/(mw*mh)/255;
    return { mw, mh, motionData: out, avg };
  }

  // ---------- Face detection ----------
  async function detectFace(){
    if(!faceDetector) return;
    const t = performance.now();
    if(t - lastFaceT < 220) return;
    lastFaceT = t;

    try{
      const bmp = await createImageBitmap(src);
      const faces = await faceDetector.detect(bmp);
      bmp.close?.();
      if(faces && faces.length){
        const b = faces[0].boundingBox;
        faceRect = { x:b.x, y:b.y, w:b.width, h:b.height };
      } else faceRect=null;
    }catch{
      faceDetector=null; faceRect=null;
      log("FaceDetector disabled (errors).");
    }
  }

  // ---------- Visual primitives ----------
  function addGrain(dstCtx, t, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    const g = dstCtx.getImageData(0,0,w,h);
    const d=g.data;
    const strength = 10 + 35*amt;
    const drift = (Math.sin(t*0.7)*0.5+0.5)*5;
    for(let i=0;i<d.length;i+=4){
      const n = (Math.sin((i*0.00013)+t*7.3)+Math.sin((i*0.000071)-t*6.1))*0.5;
      const r = (n*strength + (hash1(i+drift)-0.5)*strength)|0;
      d[i]   = clamp(d[i]   + r, 0, 255);
      d[i+1] = clamp(d[i+1] + r, 0, 255);
      d[i+2] = clamp(d[i+2] + r, 0, 255);
    }
    dstCtx.putImageData(g,0,0);
  }

  function vignette(dstCtx, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    dstCtx.save();
    dstCtx.globalCompositeOperation="multiply";
    const g=dstCtx.createRadialGradient(w*0.5,h*0.5, Math.min(w,h)*0.12, w*0.5,h*0.5, Math.max(w,h)*0.65);
    g.addColorStop(0, `rgba(255,255,255,0.90)`);
    g.addColorStop(1, `rgba(0,0,0,${0.75 + 0.95*amt})`);
    dstCtx.fillStyle=g;
    dstCtx.fillRect(0,0,w,h);
    dstCtx.restore();
  }

  function scanlines(dstCtx, t, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    dstCtx.save();
    dstCtx.globalCompositeOperation="multiply";
    dstCtx.globalAlpha = 0.12 + 0.45*amt;
    const period = lerp(3.4, 1.2, amt);
    const phase = (t*80) % period;
    dstCtx.fillStyle = "rgba(255,255,255,.16)";
    for(let y=-phase; y<h; y+=period) dstCtx.fillRect(0,y,w,1);
    dstCtx.restore();
  }

  function rollingBand(dstCtx, t, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    dstCtx.save();
    dstCtx.globalCompositeOperation="screen";
    dstCtx.globalAlpha = 0.10 + 0.30*amt;
    const bandH = Math.floor(lerp(26, 110, amt));
    const y = Math.floor(((t*90) % (h + bandH)) - bandH);
    const g = dstCtx.createLinearGradient(0,y,0,y+bandH);
    g.addColorStop(0, "rgba(255,255,255,0)");
    g.addColorStop(0.45, "rgba(255,255,255,0.25)");
    g.addColorStop(0.55, "rgba(255,255,255,0.25)");
    g.addColorStop(1, "rgba(255,255,255,0)");
    dstCtx.fillStyle=g;
    dstCtx.fillRect(0,y,w,bandH);
    dstCtx.restore();
  }

  function chromaAberration(srcCanvas, dstCtx, t, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    const dx = Math.floor((Math.sin(t*1.7)+Math.sin(t*0.37))*amt*4);
    const dy = Math.floor((Math.cos(t*1.3))*amt*2);

    dstCtx.clearRect(0,0,w,h);
    dstCtx.globalCompositeOperation="source-over";
    dstCtx.drawImage(srcCanvas, 0,0,w,h);

    dstCtx.save();
    dstCtx.globalCompositeOperation="screen";
    dstCtx.globalAlpha = 0.25*amt;
    dstCtx.drawImage(srcCanvas, dx, dy, w, h);
    dstCtx.globalAlpha = 0.18*amt;
    dstCtx.drawImage(srcCanvas, -dx, -dy, w, h);
    dstCtx.restore();
  }

  function posterize(dstCtx, levels){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    const img = dstCtx.getImageData(0,0,w,h);
    const d = img.data;
    const L = Math.max(2, Math.floor(levels));
    const step = 255/(L-1);
    for(let i=0;i<d.length;i+=4){
      d[i]   = Math.round(d[i]/step)*step;
      d[i+1] = Math.round(d[i+1]/step)*step;
      d[i+2] = Math.round(d[i+2]/step)*step;
    }
    dstCtx.putImageData(img,0,0);
  }

  function duotone(dstCtx, t, amt, c1, c2){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    const img = dstCtx.getImageData(0,0,w,h);
    const d = img.data;
    for(let i=0;i<d.length;i+=4){
      const lum = (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114)/255;
      const k = clamp(lum,0,1);
      d[i]   = (c1[0] + (c2[0]-c1[0])*k)|0;
      d[i+1] = (c1[1] + (c2[1]-c1[1])*k)|0;
      d[i+2] = (c1[2] + (c2[2]-c1[2])*k)|0;
    }
    dstCtx.putImageData(img,0,0);
    dstCtx.save();
    dstCtx.globalCompositeOperation="overlay";
    dstCtx.globalAlpha = 0.06 + 0.10*amt;
    dstCtx.fillStyle = `rgba(255,255,255,${0.35 + 0.25*Math.sin(t*0.8)})`;
    dstCtx.fillRect(0,0,w,h);
    dstCtx.restore();
  }

  function edgesSobel(srcCtx, dstCtx, amt){
    const w=srcCtx.canvas.width, h=srcCtx.canvas.height;
    const img = srcCtx.getImageData(0,0,w,h);
    const d = img.data;
    const out = dstCtx.createImageData(w,h);
    const o = out.data;

    const g = new Float32Array(w*h);
    for(let i=0, p=0; i<d.length; i+=4, p++){
      g[p] = (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114);
    }

    const K = 1.2 + 3.0*amt;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i = y*w+x;
        const gx =
          -g[i-w-1]-2*g[i-1]-g[i+w-1] +
           g[i-w+1]+2*g[i+1]+g[i+w+1];
        const gy =
          -g[i-w-1]-2*g[i-w]-g[i-w+1] +
           g[i+w-1]+2*g[i+w]+g[i+w+1];
        const mag = clamp(Math.sqrt(gx*gx+gy*gy)*K, 0, 255);
        const idx = i*4;
        o[idx]=o[idx+1]=o[idx+2]=mag;
        o[idx+3]=255;
      }
    }
    dstCtx.putImageData(out,0,0);
  }

  function halftone(srcCtx, dstCtx, t, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    const step = Math.floor(lerp(10, 5, amt));
    const tw = Math.floor(w/step), th = Math.floor(h/step);
    tiny.width=tw; tiny.height=th;
    tinctx.imageSmoothingEnabled=true;
    tinctx.drawImage(srcCtx.canvas, 0,0,tw,th);
    const img = tinctx.getImageData(0,0,tw,th).data;

    dstCtx.clearRect(0,0,w,h);
    dstCtx.fillStyle="black";
    dstCtx.fillRect(0,0,w,h);

    dstCtx.save();
    dstCtx.globalCompositeOperation="screen";
    dstCtx.translate(0.5,0.5);
    for(let y=0;y<th;y++){
      for(let x=0;x<tw;x++){
        const i=(y*tw+x)*4;
        const lum=(img[i]*0.299+img[i+1]*0.587+img[i+2]*0.114)/255;
        const r = (1-lum) * (step*0.65) * (0.7 + 0.3*Math.sin(t*0.9));
        if(r<0.2) continue;
        const cx=x*step+step*0.5;
        const cy=y*step+step*0.5;
        dstCtx.beginPath();
        dstCtx.arc(cx,cy,r,0,TAU);
        dstCtx.fillStyle="rgba(255,255,255,0.85)";
        dstCtx.fill();
      }
    }
    dstCtx.restore();
  }

  function feedback(dstCtx, srcCanvas, t, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    dstCtx.save();
    const s = 1.0 + 0.0025*amt + 0.0015*Math.sin(t*0.7);
    const ox = (Math.sin(t*1.3)+Math.sin(t*0.21))*amt*2.0;
    const oy = (Math.cos(t*0.9))*amt*1.5;

    dstCtx.globalAlpha = 0.82 + 0.15*amt;
    dstCtx.drawImage(dstCtx.canvas, (1-s)*w*0.5+ox, (1-s)*h*0.5+oy, w*s, h*s);

    dstCtx.globalCompositeOperation="screen";
    dstCtx.globalAlpha = 0.45 + 0.45*amt;
    dstCtx.drawImage(srcCanvas, 0,0,w,h);
    dstCtx.restore();
  }

  function blurBox(srcCtx, dstCtx, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    dstCtx.save();
    dstCtx.clearRect(0,0,w,h);
    const k = Math.floor(lerp(2, 10, amt));
    dstCtx.globalAlpha=1;
    dstCtx.imageSmoothingEnabled=true;
    dstCtx.drawImage(srcCtx.canvas,0,0,w,h);
    dstCtx.globalAlpha = 0.12 + 0.20*amt;
    for(let i=0;i<k;i++){
      const a = (i/k)*TAU;
      const r = lerp(0.5, 4.5, amt);
      const dx=Math.cos(a)*r, dy=Math.sin(a)*r;
      dstCtx.drawImage(srcCtx.canvas,dx,dy,w,h);
    }
    dstCtx.restore();
  }

  function pixelate(srcCtx, dstCtx, scale){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    const tw = Math.max(2, Math.floor(w*scale));
    const th = Math.max(2, Math.floor(h*scale));
    tiny.width=tw; tiny.height=th;
    tinctx.imageSmoothingEnabled=false;
    tinctx.drawImage(srcCtx.canvas, 0,0,tw,th);

    dstCtx.imageSmoothingEnabled=false;
    dstCtx.clearRect(0,0,w,h);
    dstCtx.drawImage(tiny, 0,0,w,h);
  }

  function asciiArt(srcCtx, dstCtx, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    const step = Math.floor(lerp(12, 7, amt));
    const tw = Math.floor(w/step), th = Math.floor(h/step);
    tiny.width=tw; tiny.height=th;
    tinctx.imageSmoothingEnabled=true;
    tinctx.drawImage(srcCtx.canvas, 0,0,tw,th);
    const img = tinctx.getImageData(0,0,tw,th).data;

    const chars = " .,:;i1tfLCG08@";
    dstCtx.clearRect(0,0,w,h);
    dstCtx.fillStyle="black";
    dstCtx.fillRect(0,0,w,h);
    dstCtx.fillStyle="rgba(255,255,255,0.9)";
    dstCtx.font = `${step}px ui-monospace, monospace`;
    dstCtx.textBaseline="top";

    for(let y=0;y<th;y++){
      let row="";
      for(let x=0;x<tw;x++){
        const i=(y*tw+x)*4;
        const lum = (img[i]*0.299+img[i+1]*0.587+img[i+2]*0.114)/255;
        const idx = Math.floor((1-lum)*(chars.length-1));
        row += chars[idx];
      }
      dstCtx.fillText(row, 0, y*step);
    }
  }

  function kaleidoscope(srcCtx, dstCtx, t, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    dstCtx.clearRect(0,0,w,h);
    dstCtx.save();
    dstCtx.translate(w/2,h/2);
    const n = Math.floor(lerp(6, 14, amt));
    const ang = (TAU/n);
    const rot = t*0.15;
    for(let i=0;i<n;i++){
      dstCtx.save();
      dstCtx.rotate(i*ang + rot);
      dstCtx.scale(1, (i%2===0)?1:-1);
      dstCtx.globalAlpha = 0.65 + 0.35*Math.sin(t*0.5 + i);
      dstCtx.drawImage(srcCtx.canvas, -w/2, -h/2, w, h);
      dstCtx.restore();
    }
    dstCtx.restore();
  }

  function slitScan(srcCtx, dstCtx, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    dstCtx.clearRect(0,0,w,h);
    const slices = Math.floor(lerp(40, 140, amt));
    for(let i=0;i<slices;i++){
      const x0 = Math.floor((i/slices)*w);
      const x1 = Math.floor(((i+1)/slices)*w);
      const wcol = Math.max(1, x1-x0);
      const di = Math.floor((i/slices)* (delayN-1));
      const idx = (delayHead - 1 - di + delayN) % delayN;
      dstCtx.drawImage(delayFrames[idx], x0,0,wcol,h, x0,0,wcol,h);
    }
  }

  function polarTunnel(srcCtx, dstCtx, t, amt){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    const img = srcCtx.getImageData(0,0,w,h);
    const d = img.data;
    const out = dstCtx.createImageData(w,h);
    const o = out.data;

    const cx=w/2, cy=h/2;
    const maxR = Math.min(cx,cy);
    const spin = t*(0.25 + 0.8*amt);

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const dx=x-cx, dy=y-cy;
        let r = Math.sqrt(dx*dx+dy*dy)/maxR;
        let a = Math.atan2(dy,dx) + spin;

        const k = 0.35 + 0.85*amt;
        r = Math.pow(clamp(r,0,1), 0.55 + 0.35*Math.sin(t*0.4)*amt);
        a += Math.sin(r*10 + t)*k*0.25;

        const uu = (a/TAU + 0.5) % 1;
        const vv = clamp(1 - r, 0, 1);

        const sx = Math.floor(uu*(w-1));
        const sy = Math.floor(vv*(h-1));
        const si = (sy*w + sx)*4;
        const di = (y*w + x)*4;

        const q = Math.floor(lerp(32, 8, amt));
        o[di]   = Math.floor(d[si]/q)*q;
        o[di+1] = Math.floor(d[si+1]/q)*q;
        o[di+2] = Math.floor(d[si+2]/q)*q;
        o[di+3] = 255;
      }
    }
    dstCtx.putImageData(out,0,0);
  }

  function motionScanlinesOverlay(dstCtx, motionInfo, t, amt, mode="screen"){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    const { mw, mh, motionData } = motionInfo;
    const sx = w/mw, sy = h/mh;

    dstCtx.save();
    dstCtx.globalCompositeOperation = mode;
    const period = lerp(5.0, 1.5, amt);
    const phase = (t*110) % period;

    for(let y=0;y<mh;y++){
      for(let x=0;x<mw;x++){
        const v = motionData[y*mw + x]/255;
        if(v < (0.10 + 0.10*(1-amt))) continue;
        const X = x*sx, Y = y*sy;
        const alpha = clamp((v-0.10)*2.0, 0, 1) * (0.25 + 0.75*amt);
        dstCtx.globalAlpha = alpha * (0.08 + 0.35*amt);
        const yy = (Y + phase) % period;
        dstCtx.fillStyle = "rgba(255,255,255,1)";
        dstCtx.fillRect(X, Y + yy, sx, 1);
      }
    }
    dstCtx.restore();
  }

  function faceScanOverlay(dstCtx, t, amt){
    if(!faceRect) return;
    const x=faceRect.x, y=faceRect.y, fw=faceRect.w, fh=faceRect.h;

    dstCtx.save();
    dstCtx.globalCompositeOperation="screen";
    dstCtx.globalAlpha = 0.18 + 0.40*amt;
    dstCtx.strokeStyle="rgba(255,255,255,0.8)";
    dstCtx.lineWidth=1;
    dstCtx.strokeRect(x,y,fw,fh);

    const y0 = y + fh*0.28;
    const y1 = y + fh*0.52;
    const period = lerp(3.0, 1.1, amt);
    const phase = (t*160) % period;
    dstCtx.globalAlpha = 0.10 + 0.35*amt;
    for(let yy = y0 - phase; yy < y1; yy += period){
      dstCtx.fillStyle="rgba(255,255,255,0.9)";
      dstCtx.fillRect(x, yy, fw, 1);
    }

    dstCtx.globalAlpha = 0.18 + 0.35*amt;
    const cx = x+fw*0.5 + Math.sin(t*2.3)*fw*0.03*(1-amt);
    const cy = y+fh*0.42 + Math.cos(t*2.0)*fh*0.03*(1-amt);
    dstCtx.beginPath();
    dstCtx.arc(cx,cy, Math.max(2, fw*0.03), 0, TAU);
    dstCtx.stroke();

    dstCtx.restore();
  }

  function temperatureExposureSim(dstCtx, t, amt, temp, exp){
    const w=dstCtx.canvas.width, h=dstCtx.canvas.height;
    dstCtx.save();
    const bright = 1 + exp*0.85;
    const cont   = 1 + Math.abs(exp)*0.40;
    const sat    = 1 + Math.abs(temp)*0.35;

    // filter redraw of current canvas into tmp, then back
    tctx.setTransform(1,0,0,1,0,0);
    tctx.clearRect(0,0,w,h);
    tctx.filter = `brightness(${bright}) contrast(${cont}) saturate(${sat})`;
    tctx.drawImage(dstCtx.canvas,0,0,w,h);
    tctx.filter="none";

    dstCtx.clearRect(0,0,w,h);
    dstCtx.drawImage(tmp,0,0,w,h);

    dstCtx.globalCompositeOperation="overlay";
    dstCtx.globalAlpha = 0.14 + 0.22*Math.abs(temp)*amt;
    dstCtx.fillStyle = temp>0 ? "rgba(255,160,80,1)" : "rgba(120,170,255,1)";
    dstCtx.fillRect(0,0,w,h);
    dstCtx.restore();
  }

  // ---------- Camera ----------
  async function requestStream(){
    if(isFileProtocol()){
      log("⚠ You opened via file://. Use http://localhost for reliable camera access on desktop.");
    }
    log("Requesting camera…");

    const constraints = {
      audio:false,
      video:{
        facingMode:"user",
        width:{ ideal:1280 },
        height:{ ideal:720 },
        frameRate:{ ideal:30, max:60 }
      }
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;

    // DESKTOP FIX: wait for metadata before play
    await new Promise((resolve) => {
      if (video.readyState >= 1) return resolve();
      video.onloadedmetadata = () => resolve();
    });

    await video.play();

    track = stream.getVideoTracks()[0];
    caps = (track.getCapabilities && track.getCapabilities()) ? track.getCapabilities() : null;
    setCapPills();

    if("FaceDetector" in window){
      try{
        faceDetector = new FaceDetector({ fastMode:true, maxDetectedFaces:1 });
        log("FaceDetector: available (browser API).");
      }catch(e){
        faceDetector=null;
        log("FaceDetector: init failed: " + e.message);
      }
    } else {
      log("FaceDetector: not available (expected on many browsers).");
    }

    log("Stream ready. Track label: " + (track.label || "(unknown)"));
    log("Video state: readyState=" + video.readyState + " size=" + (video.videoWidth||0) + "x" + (video.videoHeight||0));
  }

  async function stopStream(){
    if(stream) stream.getTracks().forEach(t=>t.stop());
    stream=null; track=null; caps=null; faceDetector=null; faceRect=null;
    setCapPills();
    running=false;
    startOverlay.style.display="grid";
    log("Stopped camera.");
  }

  // ---------- Preset Infrastructure ----------
  function updateHUD(){
    const p = PRESETS[presetIndex];
    presetNameEl.textContent = p.name;
    presetIdxEl.textContent  = `(${presetIndex+1}/20)`;
    descEl.textContent       = p.desc;
  }

  function resetPresetState(){
    faceRect=null;
    motionInit=false; prevImg=null;
    actx.setTransform(1,0,0,1,0,0);
    bctx.setTransform(1,0,0,1,0,0);
    actx.clearRect(0,0,fxA.width,fxA.height);
    bctx.clearRect(0,0,fxB.width,fxB.height);
    delayHead = 0;
    for(let i=0;i<delayN;i++){
      delayCtxs[i].clearRect(0,0,delayFrames[i].width, delayFrames[i].height);
    }
    PSTATE[presetIndex] = PSTATE[presetIndex] || {};
  }

  async function setPreset(i){
    presetIndex = (i + PRESETS.length) % PRESETS.length;
    updateHUD();
    resetPresetState();
    if(track) await applyConstraintsForPreset(PRESETS[presetIndex]);
  }

  // ---------- 20 Presets ----------
  const PRESETS = [
    {
      name:"01 — Baseline (truth)",
      desc:"No tricks. If this looks bad, it’s lighting/composition. Stop blaming code.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:null,
      render:(t,amt,mi)=>{ actx.clearRect(0,0,fxA.width,fxA.height); actx.drawImage(src,0,0); }
    },

    {
      name:"02 — Film Noir (hard contrast + grain)",
      desc:"High-contrast monochrome, heavy vignette, real-ish grain. Mood: interrogation room.",
      baseConstraints:{ frameRate:24 },
      advancedConstraints:{ contrast: 2.0, sharpness: 1.0 },
      render:(t,amt,mi)=>{
        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.drawImage(src,0,0);
        actx.save();
        actx.globalCompositeOperation="saturation";
        actx.fillStyle="rgba(0,0,0,1)";
        actx.fillRect(0,0,fxA.width,fxA.height);
        actx.restore();
        temperatureExposureSim(actx, t, amt, 0.0, 0.25*amt);
        posterize(actx, lerp(32, 14, amt));
        addGrain(actx, t, 0.85*amt);
        vignette(actx, 0.70*amt);
      }
    },

    {
      name:"03 — Pastel Bloom (soft + airy)",
      desc:"Soft blur + gentle bloom simulation + warm bias. Mood: fragile, almost benign.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ saturation: 1.5 },
      render:(t,amt,mi)=>{
        blurBox(sctx, actx, 0.55*amt);
        actx.save();
        actx.globalCompositeOperation="screen";
        actx.globalAlpha = 0.25 + 0.35*amt;
        actx.drawImage(actx.canvas, 0,0);
        actx.restore();
        temperatureExposureSim(actx, t, amt, 0.35, 0.15);
        vignette(actx, 0.25*amt);
      }
    },

    {
      name:"04 — Blueprint Edges (technical cold)",
      desc:"Edge map + cyan blueprint wash. Mood: you are a diagram.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ sharpness: 2.0 },
      render:(t,amt,mi)=>{
        edgesSobel(sctx, actx, 0.9*amt);
        actx.save();
        actx.globalCompositeOperation="difference";
        actx.fillStyle="white";
        actx.fillRect(0,0,fxA.width,fxA.height);
        actx.restore();
        duotone(actx, t, amt, [10,30,40], [120,240,255]);
        scanlines(actx, t, 0.35*amt);
      }
    },

    {
      name:"05 — Thermal Motion Map (heat from movement)",
      desc:"Motion becomes heat. Stillness turns dark. Move and you light up—like a target.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:null,
      render:(t,amt,mi)=>{
        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.drawImage(src,0,0);
        actx.save();
        actx.globalCompositeOperation="multiply";
        actx.globalAlpha = 0.65;
        actx.fillStyle="black";
        actx.fillRect(0,0,fxA.width,fxA.height);
        actx.restore();

        const {mw,mh,motionData,avg} = mi;
        const sx=fxA.width/mw, sy=fxA.height/mh;
        actx.save();
        actx.globalCompositeOperation="screen";
        for(let y=0;y<mh;y++){
          for(let x=0;x<mw;x++){
            const v = motionData[y*mw+x]/255;
            if(v < 0.08) continue;
            const hot = clamp((v-0.08)*2.2, 0, 1);
            const r = Math.floor(lerp(20, 255, hot));
            const g = Math.floor(lerp(0,  200, smoothstep(0.2,0.8,hot)));
            const b = Math.floor(lerp(60,  30, hot));
            actx.globalAlpha = (0.05 + 0.35*hot) * (0.5 + 0.7*amt);
            actx.fillStyle = `rgb(${r},${g},${b})`;
            actx.fillRect(x*sx, y*sy, sx, sy);
          }
        }
        actx.restore();

        chromaAberration(actx.canvas, actx, t, 0.25*amt + 0.20*avg);
        vignette(actx, 0.35*amt);
      }
    },

    {
      name:"06 — CRT Arcade (curvature + scan + phosphor)",
      desc:"Scanlines, rolling band, chroma bleed. Mood: nostalgic hardware that doesn’t care about you.",
      baseConstraints:{ frameRate:60 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.drawImage(src,0,0);

        const w=fxA.width,h=fxA.height;
        bctx.clearRect(0,0,w,h);
        const s = 1.0 + 0.03*amt;
        bctx.save();
        bctx.translate(w/2,h/2);
        bctx.scale(s,s);
        bctx.translate(-w/2,-h/2);
        bctx.drawImage(actx.canvas,0,0);
        bctx.restore();

        actx.clearRect(0,0,w,h);
        actx.drawImage(fxB,0,0);

        scanlines(actx, t, 0.9*amt);
        rollingBand(actx, t, 0.75*amt);
        chromaAberration(actx.canvas, actx, t, 0.55*amt);

        actx.save();
        actx.globalCompositeOperation="screen";
        actx.globalAlpha = 0.10 + 0.22*amt;
        blurBox(actx, bctx, 0.7*amt);
        actx.drawImage(fxB,0,0);
        actx.restore();

        vignette(actx, 0.45*amt);
      }
    },

    {
      name:"07 — Pop Poster (hard posterize + outlines)",
      desc:"Loud, graphic, aggressive. Posterized blocks + edges. Mood: propaganda portrait.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ contrast: 2.0, saturation: 2.0 },
      render:(t,amt,mi)=>{
        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.drawImage(src,0,0);
        posterize(actx, lerp(10, 5, amt));
        edgesSobel(sctx, bctx, 0.65*amt);
        actx.save();
        actx.globalCompositeOperation="multiply";
        actx.globalAlpha = 0.75;
        actx.drawImage(fxB,0,0);
        actx.restore();
        duotone(actx, t, amt, [10,10,10], [255,80,20]);
        vignette(actx, 0.25*amt);
      }
    },

    {
      name:"08 — Duotone Calm (minimal, controlled)",
      desc:"Two-color mapping, slow breathing. Mood: meditative, graphic, restrained.",
      baseConstraints:{ frameRate:24 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.drawImage(src,0,0);
        const k = 0.5 + 0.5*Math.sin(t*0.25);
        const c1 = [Math.floor(lerp(10,40,k)), Math.floor(lerp(15,55,k)), Math.floor(lerp(20,80,k))];
        const c2 = [Math.floor(lerp(230,180,k)), Math.floor(lerp(240,210,k)), Math.floor(lerp(255,230,k))];
        duotone(actx, t, amt, c1, c2);
        scanlines(actx, t, 0.15*amt);
      }
    },

    {
      name:"09 — Halftone Print (dot-screen)",
      desc:"Print-world translation. Dots become tone. Mood: newspaper reality.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        halftone(sctx, actx, t, amt);
        vignette(actx, 0.35*amt);
      }
    },

    {
      name:"10 — ASCII Terminal (textface)",
      desc:"You become characters. Mood: system output, not person.",
      baseConstraints:{ frameRate:20 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        asciiArt(sctx, actx, 0.85*amt);
        scanlines(actx, t, 0.35*amt);
        rollingBand(actx, t, 0.25*amt);
      }
    },

    {
      name:"11 — Motion Scan (body scanlines only)",
      desc:"Only movement gets scanned. Stillness hides you. Mood: security checkpoint.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.drawImage(src,0,0);
        actx.save();
        actx.globalCompositeOperation="multiply";
        actx.globalAlpha=0.7;
        actx.fillStyle="black";
        actx.fillRect(0,0,fxA.width,fxA.height);
        actx.restore();

        motionScanlinesOverlay(actx, mi, t, amt, "screen");
        vignette(actx, 0.45*amt);
      }
    },

    {
      name:"12 — Face Lock (eye/face scanlines)",
      desc:"Best-effort face detection. If it fails, the system guesses anyway.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.drawImage(src,0,0);
        const conf = faceRect ? 1.0 : 0.35;
        temperatureExposureSim(actx, t, amt, -0.15, 0.15*(1-conf));
        faceScanOverlay(actx, t, amt);
        scanlines(actx, t, 0.25 + 0.35*(1-conf));
        vignette(actx, 0.35 + 0.45*(1-conf));
      }
    },

    {
      name:"13 — Kaleidoscope (ornamental fracture)",
      desc:"Symmetry makes you alien. Mood: ornamented fracture.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        kaleidoscope(sctx, actx, t, amt);
        chromaAberration(actx.canvas, actx, t, 0.35*amt);
        vignette(actx, 0.25*amt);
      }
    },

    {
      name:"14 — Slit-Scan Time (temporal slices)",
      desc:"Your present is built out of your past. Mood: identity as accumulation error.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        delayCtxs[delayHead].drawImage(src,0,0);
        delayHead = (delayHead+1)%delayN;

        slitScan(sctx, actx, amt);
        scanlines(actx, t, 0.25*amt);
        vignette(actx, 0.30*amt);
      }
    },

    {
      name:"15 — Dream Smear (feedback + blur)",
      desc:"Soft but unstable. Memory trails, ghosting, gentle bleed.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        blurBox(sctx, bctx, 0.55*amt);
        feedback(actx, fxB, t, 0.75*amt);
        temperatureExposureSim(actx, t, amt, 0.15, 0.10);
        vignette(actx, 0.35*amt);
      }
    },

    {
      name:"16 — Lissajous Warp (math displacement field)",
      desc:"A moving displacement field driven by coupled sine equations.",
      baseConstraints:{ frameRate:60 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        const w=fxA.width,h=fxA.height;
        const img = sctx.getImageData(0,0,w,h);
        const d = img.data;
        const out = actx.createImageData(w,h);
        const o = out.data;

        const ax = 2 + Math.floor(4*amt);
        const ay = 3 + Math.floor(5*amt);
        const bx = 1.7 + 2.2*amt;
        const by = 2.3 + 2.6*amt;
        const amp = 8 + 26*amt;

        for(let y=0;y<h;y++){
          for(let x=0;x<w;x++){
            const nx = (x/w)*TAU;
            const ny = (y/h)*TAU;
            const dx = Math.sin(nx*ax + t*bx) + Math.sin(ny*(ax+1) - t*(bx*0.7));
            const dy = Math.cos(ny*ay + t*by) + Math.cos(nx*(ay+1) - t*(by*0.6));
            const sx = clamp((x + dx*amp)|0, 0, w-1);
            const sy = clamp((y + dy*amp)|0, 0, h-1);
            const si = (sy*w + sx)*4;
            const di = (y*w + x)*4;
            o[di]=d[si]; o[di+1]=d[si+1]; o[di+2]=d[si+2]; o[di+3]=255;
          }
        }
        actx.putImageData(out,0,0);
        chromaAberration(actx.canvas, actx, t, 0.45*amt);
        scanlines(actx, t, 0.25*amt);
        vignette(actx, 0.35*amt);
      }
    },

    {
      name:"17 — Interference Moiré (phase-locked sin grids + face coupling)",
      desc:"Moiré fields + phase interference. If face detection exists, it couples to wave phase.",
      baseConstraints:{ frameRate:60 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        const w=fxA.width,h=fxA.height;
        actx.clearRect(0,0,w,h);
        actx.drawImage(src,0,0);

        const fx = faceRect ? (faceRect.x + faceRect.w*0.5)/w : 0.5;
        const fy = faceRect ? (faceRect.y + faceRect.h*0.5)/h : 0.5;
        const f = lerp(10, 42, amt);
        const g = lerp(13, 55, amt);
        actx.save();
        actx.globalCompositeOperation="overlay";
        actx.globalAlpha = 0.12 + 0.35*amt;
        for(let y=0;y<h;y+=2){
          const ny = y/h;
          const a = Math.sin((ny*g + t*0.8 + fy*3.0)*TAU);
          const v = 0.5 + 0.5*a;
          actx.fillStyle = `rgba(255,255,255,${0.08 + 0.22*v})`;
          actx.fillRect(0,y,w,1);
        }
        for(let x=0;x<w;x+=2){
          const nx = x/w;
          const a = Math.sin((nx*f - t*0.7 + fx*3.0)*TAU);
          const v = 0.5 + 0.5*a;
          actx.fillStyle = `rgba(0,0,0,${0.06 + 0.20*v})`;
          actx.fillRect(x,0,1,h);
        }
        actx.restore();

        motionScanlinesOverlay(actx, mi, t, 0.65*amt, "screen");
        faceScanOverlay(actx, t, 0.55*amt);

        vignette(actx, 0.40 + 0.35*amt);
      }
    },

    {
      name:"18 — Stochastic Mask Hallucination (motion + random thresholds)",
      desc:"A deliberately irrational matte: motion drives stochastic cut, recolors by noisy math.",
      baseConstraints:{ frameRate:30 },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        const w=fxA.width,h=fxA.height;
        actx.clearRect(0,0,w,h);

        const {mw,mh,motionData,avg} = mi;
        const sx=w/mw, sy=h/mh;

        actx.fillStyle="black";
        actx.fillRect(0,0,w,h);
        actx.save();
        actx.globalCompositeOperation="screen";
        for(let y=0;y<mh;y++){
          for(let x=0;x<mw;x++){
            const v = motionData[y*mw+x]/255;
            const n = hash1(x*17.3 + y*91.7 + Math.floor(t*9)*13.1);
            const thr = lerp(0.12, 0.30, 1-amt) + 0.18*n;
            if(v < thr) continue;
            const k = clamp((v-thr)*2.8, 0, 1);
            const rr = Math.floor(lerp(40, 255, k));
            const gg = Math.floor(lerp(10, 120, smoothstep(0.1,0.7,k)));
            const bb = Math.floor(lerp(90, 20, k));
            actx.globalAlpha = (0.06 + 0.55*k) * (0.6 + 0.6*amt);
            actx.fillStyle = `rgb(${rr},${gg},${bb})`;
            actx.fillRect(x*sx, y*sy, sx, sy);
          }
        }
        actx.restore();

        actx.save();
        actx.globalCompositeOperation="screen";
        actx.globalAlpha = 0.18 + 0.25*amt;
        actx.drawImage(src,0,0);
        actx.restore();

        chromaAberration(actx.canvas, actx, t, 0.55*amt + 0.25*avg);
        scanlines(actx, t, 0.55*amt);
        vignette(actx, 0.55*amt);
      }
    },

    {
      name:"19 — Polar Tunnel + Poster Steps (spatial re-map)",
      desc:"Polar remapping + quantization. Mood: camera becomes a tunnel instrument.",
      baseConstraints:{ frameRate:60 },
      advancedConstraints:{ zoom: 2.0 },
      render:(t,amt,mi)=>{
        tctx.setTransform(1,0,0,1,0,0);
        tctx.clearRect(0,0,fxA.width,fxA.height);
        tctx.drawImage(src,0,0);

        polarTunnel(tctx, actx, t, amt);
        rollingBand(actx, t, 0.45*amt);
        scanlines(actx, t, 0.35*amt);
        vignette(actx, 0.35 + 0.35*amt);
      }
    },

    {
      name:"20 — Constraint Roulette + Algebraic Mash (improvised)",
      desc:"Every few seconds it rolls constraints (if available) and combines 3 operators driven by math.",
      baseConstraints:{ frameRate:30, width:{ ideal:1280 }, height:{ ideal:720 } },
      advancedConstraints:{ },
      render:(t,amt,mi)=>{
        const st = (PSTATE[presetIndex] = PSTATE[presetIndex] || {});
        if(!st.rng) st.rng = rng(1337);
        if(st.nextRoll === undefined) st.nextRoll = t + 0.1;
        if(st.ops === undefined) st.ops = [0,1,2];

        if(t > st.nextRoll){
          st.nextRoll = t + lerp(3.0, 6.0, st.rng());
          const ops = new Set();
          while(ops.size < 3) ops.add(Math.floor(st.rng()*9));
          st.ops = Array.from(ops);

          if(track && track.applyConstraints && caps){
            const adv = {};
            function pickCap(name){
              const c = caps[name];
              if(!c) return null;
              if(typeof c === "object" && c.min !== undefined && c.max !== undefined){
                return lerp(c.min, c.max, st.rng());
              }
              if(Array.isArray(c)){
                return c[Math.floor(st.rng()*c.length)];
              }
              return null;
            }
            const z  = pickCap("zoom");
            const ec = pickCap("exposureCompensation");
            const fd = pickCap("focusDistance");
            const ct = pickCap("colorTemperature");
            if(z!==null)  adv.zoom = z;
            if(ec!==null) adv.exposureCompensation = ec;
            if(fd!==null) adv.focusDistance = fd;
            if(ct!==null) adv.colorTemperature = ct;

            const fps = 12 + Math.floor(st.rng()*49);
            track.applyConstraints({ frameRate: fps, advanced:[adv] }).catch(()=>{});
          }
        }

        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.drawImage(src,0,0);

        const A = Math.sin(t*0.73) * (0.35 + 0.65*amt);
        const B = Math.cos(t*0.41) * (0.35 + 0.65*amt);
        const C = Math.sin(t*1.21 + A*2.0) * (0.35 + 0.65*amt);

        for(const op of st.ops){
          switch(op){
            case 0:
              posterize(actx, lerp(22, 4, (0.5+0.5*A)));
              break;
            case 1:
              chromaAberration(actx.canvas, actx, t, 0.25 + 0.55*amt*(0.5+0.5*B));
              break;
            case 2:
              scanlines(actx, t, 0.25 + 0.65*amt*(0.5+0.5*C));
              rollingBand(actx, t, 0.15 + 0.55*amt*(0.5+0.5*A));
              break;
            case 3: {
              const p1 = [Math.floor(20+200*hash1(st.ops[0]+t*0.1)), Math.floor(10+90*hash1(st.ops[1]+t*0.2)), Math.floor(30+120*hash1(st.ops[2]+t*0.3))];
              const p2 = [Math.floor(120+120*hash1(st.ops[2]+t*0.4)), Math.floor(160+80*hash1(st.ops[0]+t*0.5)), Math.floor(210+40*hash1(st.ops[1]+t*0.6))];
              duotone(actx, t, amt, p1, p2);
              break;
            }
            case 4:
              edgesSobel(sctx, bctx, 0.6*amt);
              actx.save();
              actx.globalCompositeOperation="multiply";
              actx.globalAlpha = 0.55 + 0.25*amt;
              actx.drawImage(fxB,0,0);
              actx.restore();
              break;
            case 5:
              feedback(actx, src, t, 0.55 + 0.35*amt);
              break;
            case 6:
              pixelate(sctx, actx, lerp(0.25, 0.06, 0.5+0.5*B));
              break;
            case 7: {
              const w=fxA.width,h=fxA.height;
              actx.save();
              actx.globalCompositeOperation="overlay";
              actx.globalAlpha = 0.10 + 0.25*amt;
              const f = lerp(12, 52, 0.5+0.5*A);
              for(let y=0;y<h;y+=2){
                const ny=y/h;
                const v = 0.5+0.5*Math.sin((ny*f + t*0.9)*TAU);
                actx.fillStyle = `rgba(255,255,255,${0.06+0.22*v})`;
                actx.fillRect(0,y,w,1);
              }
              actx.restore();
              break;
            }
            case 8:
              motionScanlinesOverlay(actx, mi, t, 0.85*amt, "screen");
              break;
          }
        }

        faceScanOverlay(actx, t, 0.25 + 0.45*amt);
        vignette(actx, 0.35 + 0.35*amt);
      }
    },
  ];

  // ---------- Controls ----------
  function onKey(e){
    if(e.key==="ArrowRight") setPreset(presetIndex+1);
    if(e.key==="ArrowLeft")  setPreset(presetIndex-1);
    if(e.key==="f"||e.key==="F") enterFullscreen();
    if(e.key==="r"||e.key==="R") applyConstraintsForPreset(PRESETS[presetIndex]);
    if(e.key===" ") paused = !paused;
  }
  window.addEventListener("keydown", onKey);

  prevBtn.addEventListener("click", ()=>setPreset(presetIndex-1));
  nextBtn.addEventListener("click", ()=>setPreset(presetIndex+1));
  fsBtn.addEventListener("click", ()=>enterFullscreen());
  reapplyBtn.addEventListener("click", ()=>applyConstraintsForPreset(PRESETS[presetIndex]));
  stopBtn.addEventListener("click", ()=>stopStream());

  intensityEl.addEventListener("input", ()=>{
    intensity = clamp(parseInt(intensityEl.value,10)/100, 0, 1);
    intValEl.textContent = Math.round(intensity*100) + "%";
  });

  // ---------- Main loop ----------
  function tick(){
    if(!running) return;

    if(!paused){
      sctx.setTransform(1,0,0,1,0,0);
      sctx.clearRect(0,0,src.width,src.height);

      // DESKTOP FIX: safe draw + wait-for-frames gate
      const ok = drawVideoCoverSafe(sctx);
      if(!ok){
        // show the waiting screen in output too (so you see something, not grey)
        actx.setTransform(1,0,0,1,0,0);
        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.drawImage(src,0,0);
        blitToScreen();
        requestAnimationFrame(tick);
        return;
      }

      const mi = computeMotionMap();
      detectFace();

      delayCtxs[delayHead].drawImage(src,0,0);
      delayHead = (delayHead+1) % delayN;

      const t = nowS() - (tStart*0.001);
      const amt = intensity;

      try{
        PRESETS[presetIndex].render(t, amt, mi);
      }catch(e){
        actx.clearRect(0,0,fxA.width,fxA.height);
        actx.fillStyle="black"; actx.fillRect(0,0,fxA.width,fxA.height);
        actx.fillStyle="white"; actx.font="14px ui-monospace, monospace";
        actx.fillText("Preset error: " + (e.message||e), 10, 20);
      }

      blitToScreen();
    }

    requestAnimationFrame(tick);
  }

  async function start(withFs){
    resize();
    dbgEl.textContent = "";
    log("Boot… protocol=" + location.protocol);
    if(isFileProtocol()){
      log("⚠ file:// detected. If camera fails on desktop, run via localhost:");
      log("    python -m http.server 8000");
      log("    then open: http://localhost:8000/THIS_FILE.html");
    }

    try{
      await requestStream();
      if(withFs) await enterFullscreen();
      await setPreset(0);

      startOverlay.style.display="none";
      running=true; paused=false;
      tStart = performance.now();
      requestAnimationFrame(tick);
    } catch(e){
      log("FAILED: " + (e.name||"") + " " + (e.message||e));
      log("Common desktop causes:");
      log(" - denied permissions (address bar camera icon)");
      log(" - opened via file:// (use localhost)");
      log(" - another app using camera (Zoom/Teams/OBS)");
      log(" - wrong camera selected in browser settings");
      console.error(e);
    }
  }

  startBtn.addEventListener("click", ()=>start(false));
  startFsBtn.addEventListener("click", ()=>start(true));

  // ---------- Boot ----------
  resize();
  updateHUD();
  setCapPills();
  log("Ready. Click START.");

})();
</script>
</body>
</html>
